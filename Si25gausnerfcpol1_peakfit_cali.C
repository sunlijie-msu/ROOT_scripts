#include <iostream>
#include <fstream>
#include <iomanip.h>
#include <math.h>
#include <time.h>
#include <map>
#include <TROOT.h>
#include <TSystem.h>
#include <TStyle.h>
#include <TCutG.h>
#include "TChain.h"
#include "TStyle.h"
#include "TCanvas.h"
#include "TEllipse.h"
#include "TString.h"
#include "TGraph.h"
#include "TGraphErrors.h"
#include "TSpectrum.h"
#include "TVirtualFitter.h"
#include "TFitResult.h"
#include "TFitResultPtr.h"
#include "TRandom.h"
#include "TFile.h"
#include "TTree.h"
#include "TH1.h"
#include "TH1D.h"
#include "TH2.h"
#include "TF1.h"
#include "TMath.h"
#include "TPaveText.h"
#include "TPad.h"
#include "TAxis.h"
#include "TClass.h"
#include "TMatrixD.h"
#include "TVectorD.h"
#include "string.h"
#include "stdlib.h"
#include "stdio.h"
#include "TLegend.h"
using namespace std;
void Si25gausnerfcpol1_peakfit_cali()// peak draw-fit (gausn+erfc+pol1) used for 6 peaks (23Al or 25Si) for each SeGA detector (after gain matching) to get the peak-maximum for each SeGA detector,
{//maximums go to excel, combine 12 maximums for 23Al and 25Si in excel then store them in 12 .dat files then use graphpol1fit_band_energy_cali.C to extract formal ax+b parameters from fitting.
	//save each peak fit, and tau, sigma, maximum as figures
	time_t tim;
	struct tm *at;
	char now[80];
	int irawroot;
	char rawrootname[300];
	double slope[300],slopeerr[300];
	double intercept[300],intercepterr[300];
	const int ID1=0;// no need to modify i=ID1//which detector
	const int ID2=15;// no need to modify i<=ID2//which detector
	
	int binwidth=1;
//	int binnum=(upperlimit-lowerlimit)/binwidth;
	int minrange=0,maxrange=0,minbin,maxbin;
	double sigma=1,thresh=0.8,sigmab=20;//adjust
	float gaplow=70.,gaphigh=70.;//fitting range随分辨不同调整//no need to modify
	unsigned long i;
	int jj,ii,ibin,k,ipeak;
	char paraprint[30],b_name[200],histo_name[200],h_name[200],hfit_name[200],hcali_name[200],tauflag[200];
	char command1[100],command2[100];
	//string paraprint[30],h_name[80],histo_name[80],b_name[80],hfit_name[80],hcali_name[80];
	TCanvas *canvaspeak[300];
	TCanvas *canvascali[300];
	TH1F *histo[ID2+1];//TH1F peak search+gauss fit,creat histograms
	const int nummax=6;//search peaknumber can be many, fitnumber can be limited to 3//no need to modify
	TF1 *total[nummax];//creat function
	TF1 *p[nummax], *g[nummax], *b[nummax];
	TGraph *graph1[300], *graph2[300], *graph[300];//TGraph刻度
	int peaknum=nummax;
	Double_t peakx[nummax],peakxerr[nummax];
	Double_t peaky[nummax],peakyerr[nummax];
	Double_t sig[nummax],sigerr[nummax];
	Double_t tau[nummax],tauerr[nummax];
	// 	float *peakx;//if you don't know how many peaks will be found, use this
	// 	float *peaky;//if you don't know how many peaks will be found, use this
//	double energylit[6]={451.7820, 493.1847, 944.6500, 1460.8200, 1612.6869, 2614.5110};//25Si
//	double energyliterr[6]={0.384111, 0.455554, 	0.353553, 0.005000, 0.384111, 0.010000};//25Si
	double energylit[6]={450.6924, 1460.8200, 1599.5500, 2614.5110, 2904.7794, 7801.4706};//23Al
	double energyliterr[6]={0.137758, 0.005000, 0.365148, 0.010000, 0.603657, 0.485071};//23Al
	float peakmin;
	float chtemp;
	double par[nummax][5],parerr[nummax][5];//随峰数不同改动par[peaknum][3]//adjust
	double parchi[nummax],parNDF[nummax];
//  	ifstream infilelowerlimit("D:/X/out/Si25/lowerlimitforcali23Al.dat",ios::in);//12 SeGA detectors//modify
//  	ifstream infileupperlimit("D:/X/out/Si25/upperlimitforcali23Al.dat",ios::in);//12 SeGA detectors
 	ifstream infilelowerlimit("D:/X/out/Si25/lowerlimitforcali25Si.dat",ios::in);//12 SeGA detectors
 	ifstream infileupperlimit("D:/X/out/Si25/upperlimitforcali25Si.dat",ios::in);//12 SeGA detectors
	int lowerlimit[ID2+1][nummax],upperlimit[ID2+1][nummax];
	for(i=ID1;i<=ID2;i++)//which detector
	{
		if(i==8) continue;
		for(ii=0;ii<nummax;ii++)//which peak
		{
			infilelowerlimit>>lowerlimit[i][ii];
			infileupperlimit>>upperlimit[i][ii];
		}
	}
	for(i=ID1;i<=ID2;i++)//which detector
	{
		if(i==8) continue;
		for(ii=0;ii<nummax;ii++)//which peak
		{
			cout<<upperlimit[i][ii]<<"	";
		}
		cout<<endl;
	}
	// 	int lowerlimit[6]={3400,3700,7200,11100,12300,20000};//portal//search for peaks in this range
	// 	int upperlimit[6]={3550,3850,7330,11350,12500,20220};//search for peaks in this range
	//float energy[6]={778.90,867.39,964.06,1085.84,1112.09,1408.02};//adjust
	//float energy[8]={121.78,244.70,344.28,778.90,964.06,1085.84,1112.09,1408.02};
	//float energy[11]={121.8, 244.7, 344.3, 411.1, 444.0, 778.9, 867.4, 964.1, 1085.8, 1112.0, 1408.0}//wangjianguo 152Eu
	//float intensity[11]={28.37,7.53,26.57,2.23,3.12,12.97,4.214,14.63,10.13,13.54,20.85};//wangjianguo 152Eu
	//float energy[5]={80.9, 276.4,302.8,356.0,383.8};//wangjianguo 133Ba
	//float intensity[5]={34.11,7.147,18.30,61.94,8.905};//wangjianguo 133Ba
	//float energy[2]={1173.2,1332.5};//wangjianguo 60Co
	//float intensity[2]={99.857,99.983};//wangjianguo 60Co
	//float energy[8]={401,943,1917,2162,2307,5805,3463,4252};
	
//	int runstart=123,runstop=140;
	//cout<<"input runstart:";
	//cin>>runstart;
	//cout<<"input runstop:";
	//cin>>runstop;
	ofstream outfile("D:/X/out/Si25/outfile/peakcali.dat",ios::out);
	ofstream outfile2("D:/X/out/Si25/outfile/peakcalipara.dat",ios::out);
	//FILE *outfile=fopen ("X:/aaron/peakcali.dat","a");
	//for(irawroot=runstart; irawroot<=runstop; irawroot++)
	//{
	//if()continue;
	sprintf(rawrootname,"%s","X:/aaron/rootfiles_aftermatching/run-all_after_matching_25Si.root");//modify
//	sprintf(rawrootname,"%s","X:/aaron/rootfiles_aftermatching/run-all_after_matching_23Al.root");
	TFile *fin = new TFile(rawrootname);//after this statement, you can use any ROOT command1 for this rootfile
	//TTree *tree = (TTree*)fin->Get("tree");
	//TTree *tree = (TTree*)fin->Get("tree");//此句可有可无
	//	unsigned long nentries=tree->GetEntries();//读事件数
	cout<<rawrootname<<endl;
	//	cout<<"  Entries="<<nentries<<endl;
	//Int_t adc[5][ID];//define the variables to hold the read values //△treeFill
	//tree->SetBranchAddress("adc", adc);//△treeFill
	//cout<<"input branch name for cali: ";
	//sprintf(b_name,"%s","Clover");
//	sprintf(b_name,"%s","SeGA_ungated");
	//cin>>b_name;//input the branch name you want to search its peaks
	// 	while(strcmp(b_name,"DSSD2e")!=0&&strcmp(b_name,"DSSD3e")!=0&&strcmp(b_name,"QSD1e")!=0)
	// 	{
	// 		cout<<"Wrong b_name!"<<endl;
	// 		cout<<"input b_name for cali again: ";
	// 		cin>>b_name;
	// 	}
	// tree draw *****************
// 	sprintf(b_name,"%s","SeGAenergy");
// 	for(ii=ID1;ii<=ID2;ii++)
// 	{
// 		sprintf(histo_name,"h%s%s%d%s",b_name,"[",ii,"]");
// 		histo[ii] = new TH1F(histo_name,histo_name,binnum,lowerlimit,upperlimit);//name a histogram,hDSSD1AL[0]
// 	}//name sequence decide the TH1F sequence in rootfile, name histograms if use tree->draw
// 	for(ii=ID1;ii<=ID2;ii++)
// 	{
// 		sprintf(command1,"%s%s%d%s%s%s%d%s",b_name,"[",ii,"]>>h",b_name,"[",ii,"]");
// 		puts(command1);
// 		sprintf(command2,"%s%s%d%s",b_name,"[",ii,"]>0");
// 		puts(command2);
// 		outTree->Draw(command1,command2);//tree-Draw("DSSD1AL[0]>>hDSSD1AL[0]")
// 	}
	// tree draw *******************
	// get histogram *******************
	for(i=ID1;i<=ID2;i++)//which detector
	{
		sprintf(b_name,"%s%02d","SeGA_",i);
		histo[i] = (TH1F*)fin->Get(b_name);
		histo[i]->Rebin(10);//0.1 ADC channel per bin was used in root file, here must rebin 10
		//histo[i]->GetYaxis()->SetRangeUser(0,4000);//zoom the axis
	}
	// get histogram *******************
	// 	{
	// 		sprintf(command1,"%s%s%s%s%d%s",b_name,">>h",b_name,"[",ii,"]");
	// 		puts(command1);
	// 		sprintf(command2,"%s","DSSD2e<100&&QSD1e<100");
	// 		puts(command2);
	// 		tree->Draw(command1,command2);//tree-Draw("DSSD1AL[0]>>hDSSD1AL[0]")
	// 	}
	// 		for(i=0;i<nentries;i++)
	// 		{
	// 			memset(adc,0,sizeof(adc));
	// 			for(ii=0;ii<32;ii++)
	// 			{
	// 				tree->GetEntry(i);//Read the entry i in the tree (the i th event in the tree)
	// 				//sprintf(b_name,"%s%s%d%s",h_name,"ch[",ii,"]");
	// 				if(strcmp(h_name,"adc[2]")==0)
	// 					histo[ii]->Fill(adc[2][ii]);//Fill Branch for cali
	// 				else if(strcmp(h_name,"adc[3]")==0)
	// 					histo[ii]->Fill(adc[3][ii]);//Fill Branch for cali
	// 			}//Fill(Float_t), not Fill(char *)
	// 			if(i%iprint==0)
	// 			{
	// 				time(&tim);
	// 				at=localtime(&tim);
	// 				strftime(now,79,"%Y-%m-%d %H:%M:%S",at);
	// 				cout<<now;
	// 				printf(" complete %.1f%s\n",100*(float)i/(float)nentries,"%");
	// 			}
	// 			if(i+1>=imax)break;
	// 		}//for(i=0;i<nentries;i++) △treedraw
	//从tree Draw TH1F或者从root文件Get TH1F形成新的TH1F用于寻峰拟合
	//for(ii=0;ii<16;ii++)
	//{
	//sprintf(h_name,"%s%d","h300ALch",ii);
	//h300AL[ii] = (TH1D*)fin->Get(h_name);
	//}//read histograms from a file, no need to name histograms, also cannot rebin
	// 	h300AL[0]=(TH1D*)fin->Get("D300ALch0");

	for(i=15;i<=15;i++)//which SeGA detector modify
	{
		if(i==8) continue;
		sprintf(hfit_name,"%s%d","fit_Rn_all_SeGA_",i);
		canvaspeak[i]=new TCanvas(hfit_name,hfit_name,900,600);//建立画布
		canvaspeak[i]->cd();//进入画布
		histo[i]->SetTitle(hfit_name);//图名
		histo[i]->GetXaxis()->SetTitle("Channel");//轴名
		histo[i]->GetYaxis()->SetTitle("Counts");//轴名
		histo[i]->GetXaxis()->CenterTitle();//居中
		histo[i]->GetYaxis()->CenterTitle();//居中
		histo[i]->GetXaxis()->SetLabelFont(132);//坐标字体
		histo[i]->GetYaxis()->SetLabelFont(132);//坐标字体
		histo[i]->GetXaxis()->SetTitleFont(132);//轴名字体
		histo[i]->GetYaxis()->SetTitleFont(132);//轴名字体
		histo[i]->GetXaxis()->SetTitleOffset(1.2);//轴名偏移
		histo[i]->GetYaxis()->SetTitleOffset(1.3);//轴名偏移		
		histo[i]->Draw();
//		TSpectrum *s = new TSpectrum();
		//TH1F *histob = s->Background(histo[i], sigmab, "same");
		//histo[i]->Add(histob, -1);
		//TSpectrum contains advanced spectra processing functions for 1- and 2-dimensional background estimation, smoothing, deconvolution, peak search and fitting, and orthogonal transformations.
//		peaknum = s->Search(histo[i],sigma,"",thresh);//△寻峰个数
		// Int_t Search(const TH1* hist, Double_t sigma = 2, Option_t* option = "", Double_t threshold = 0.05)
		//hin: pointer to the histogram of source spectrum
		//sigma: sigma of searched peaks, for details we refer to manual
		//threshold: (default=0.05) peaks with amplitude less than threshold*highest_peak are discarded. 0 By default, the background is removed before deconvolution. Specify the option "nobackground" to not remove the background.
		//printf("Found %d candidate peaks to fit in DSSD%d.\n",peaknum,i);
// 		peakx = s->GetPositionX();//△寻峰道数
// 		peaky = s->GetPositionY();//△寻峰道数
// 		for(ii=0;ii<peaknum;ii++)
// 		{
// 			k=ii;
// 			peakmin=peakx[k];
// 			for(jj=ii+1;jj<peaknum;jj++)
// 			{
// 				if(peakx[jj]<peakmin)
// 				{
// 					//cout<<peakx[jj]<<" "<<peakmin<<endl;
// 					k=jj;
// 					peakmin=peakx[k];
// 					chtemp=peakx[jj];
// 					peakx[jj]=peakx[ii];
// 					peakx[ii]=chtemp;
// 
// 					chtemp=peaky[jj];
// 					peaky[jj]=peaky[ii];
// 					peaky[ii]=chtemp;
// 				}
// 			}	
// 		}
		//TMath::Sort(peaknum, peakxn, peakx);
// 		for(jj=0;jj<peaknum;jj++)
// 		{
// 			outfile<<hfit_name<<" canvaspeak"<<jj<<"	xpos="<<peakx[jj]<<"	ypos="<<peaky[jj]<<endl;//输出文本查看
// 		}
//		if(peaknum>nummax) peaknum=nummax;//not more than 10 peaks
		for(ii=0;ii<=5;ii++)//which peak in one SeGA detector modify =0<=5
		{
			peaky[ii]=0;
			histo[i]->GetXaxis()->SetRangeUser(lowerlimit[i][ii],upperlimit[i][ii]);
			peaky[ii]=histo[i]->GetMaximum();
			peakx[ii]=histo[i]->GetBinCenter(histo[i]->GetMaximumBin());
			if(ii==0){	gaplow=62; gaphigh=62;}//452 25Si modify
			if(ii==1){	gaplow=60; gaphigh=50;}//493
			if(ii==2){	gaplow=62; gaphigh=65;}//945
			if(ii==3){	gaplow=75; gaphigh=70;}//1461
			if(ii==4){	gaplow=90; gaphigh=80;}//1612
			if(ii==5){	gaplow=110; gaphigh=110;}//2614
// 			if(ii==0){	gaplow=78; gaphigh=89;}//452 25Si 3 bad dets modify
// 			if(ii==1){	gaplow=70; gaphigh=50;}//493
// 			if(ii==2){	gaplow=72; gaphigh=75;}//945
// 			if(ii==3){	gaplow=85; gaphigh=80;}//1461
// 			if(ii==4){	gaplow=100; gaphigh=100;}//1612
// 			if(ii==5){	gaplow=120; gaphigh=120;}//2614
// 			if(ii==0){	gaplow=48; gaphigh=55;}//451 23Al
// 			if(ii==1){	gaplow=75; gaphigh=75;}//1461
// 			if(ii==2){	gaplow=60; gaphigh=75;}//1600
// 			if(ii==3){	gaplow=110; gaphigh=110;}//2614
// 			if(ii==4){	gaplow=110; gaphigh=110;}//2905
// 			if(ii==5){	gaplow=190; gaphigh=190;}//7803
			histo[i]->GetXaxis()->SetRangeUser(peakx[ii]-gaplow,peakx[ii]+gaphigh);//zoom the axis
			//cout<<"************"<<peakx[ii]<<"	"<<peaky[ii]<<endl;
			minrange=peakx[ii]-gaplow;
			maxrange=peakx[ii]+gaphigh;
			minbin=histo[i]->FindBin(minrange);
			maxbin=histo[i]->FindBin(maxrange);
			ibin=minbin;
			while(histo[i]->GetBinContent(ibin)<(peaky[ii]/2))
			{
				ibin++;
				if(ibin>=maxbin)break;
			}
			double sigmaguess=2*(peakx[ii]-histo[i]->GetBinCenter(ibin))/2.355;
			float highcounts=0,lowcounts=0;
			for (jj=0;jj<10;jj++)
			{
				highcounts+=histo[i]->GetBinContent(maxbin-jj);
				lowcounts+=histo[i]->GetBinContent(minbin+jj);
			}
			highcounts=highcounts/10; lowcounts=lowcounts/10;
			double aguess=(highcounts-lowcounts)/(maxrange-minrange);
			double bguess=lowcounts-minrange*aguess;
			cout<<aguess<<"	"<<bguess<<"	"<<sigmaguess<<"	"<<peakx[ii]<<"	"<<peaky[ii]<<endl;
// 			total[ii]=new TF1("total","[0]*x+[1]+[2]/2/[3]*exp(0.5*([4]*[4]/([3]*[3]))+(x-[5])/[3])*ROOT::Math::erfc(1/sqrt(2)*([4]/[3]+(x-[5])/[4]))",peakx[ii]-gaplow,peakx[ii]+gaphigh);//高斯拟合，调节合适的拟合range / Glassman PLB2018 low-energy tail
// 			g[ii]=new TF1("g","gausn",peakx[ii]-gaplow,peakx[ii]+gaphigh);// The [2]-N parameter in total is equivalent to the Constant in gausn
// 			p[ii]=new TF1("p","[0]*x+[1]-[0]*x-[1]+[2]/2/[3]*exp(0.5*([4]*[4]/([3]*[3]))+(x-[5])/[3])*ROOT::Math::erfc(1/sqrt(2)*([4]/[3]+(x-[5])/[4]))",peakx[ii]-gaplow,peakx[ii]+gaphigh);//pure peak
// 			b[ii]=new TF1("b","[0]*x+[1]",peakx[ii]-gaplow,peakx[ii]+gaphigh);//pure bkg

			total[ii]=new TF1("total","[0]*x+[1]+sqrt(3.141592654/2)*[2]/[3]*[4]*exp(0.5*([4]*[4]/([3]*[3]))+(x-[5])/[3])*ROOT::Math::erfc(1/sqrt(2)*([4]/[3]+(x-[5])/[4]))",peakx[ii]-gaplow,peakx[ii]+gaphigh);//高斯拟合，调节合适的拟合range / Glassman PRC2019 low-energy tail
			g[ii]=new TF1("g","gausn",peakx[ii]-gaplow,peakx[ii]+gaphigh);// The [2]-N parameter in total is equivalent to the Constant in gausn
			p[ii]=new TF1("p","[0]*x+[1]-[0]*x-[1]+sqrt(3.141592654/2)*[2]/[3]*[4]*exp(0.5*([4]*[4]/([3]*[3]))+(x-[5])/[3])*ROOT::Math::erfc(1/sqrt(2)*([4]/[3]+(x-[5])/[4]))",peakx[ii]-gaplow,peakx[ii]+gaphigh);//pure peak
			b[ii]=new TF1("b","[0]*x+[1]",peakx[ii]-gaplow,peakx[ii]+gaphigh);//pure bkg
			total[ii]->SetNpx((gaphigh+gaplow)*10);
			g[ii]->SetNpx((gaphigh+gaplow)*10);
			p[ii]->SetNpx((gaphigh+gaplow)*10);
			b[ii]->SetNpx((gaphigh+gaplow)*10);
			// 			total[ii]=new TF1("total","[0]*x+[1]+[2]/2/[3]*exp([4]*[4]/2/[3]/[3]+(x-[5])/[3])*(1-ROOT::Math::erf([4]*[4]+[3]*(x-[5])/sqrt(2)/[4]/[3]))",peakx[ii]-gaplow,peakx[ii]+gaphigh);//高斯拟合，调节合适的拟合range / Bennett
			// 			g[ii]=new TF1("g","gausn",peakx[ii]-gaplow,peakx[ii]+gaphigh);
			// 			p[ii]=new TF1("p","[0]*x+[1]-[0]*x-[1]+[2]/2/[3]*exp([4]*[4]/2/[3]/[3]+(x-[5])/[3])*(1-ROOT::Math::erf([4]*[4]+[3]*(x-[5])/sqrt(2)/[4]/[3]))",peakx[ii]-gaplow,peakx[ii]+gaphigh);
			//  			b[ii]=new TF1("b","[0]*x+[1]",peakx[ii]-gaplow,peakx[ii]+gaphigh);//pure bkg

			//total[ii]->SetParameters(0.1,15,peaky[ii],10,10,peakx[ii]);//initial value [0]-A, [1]-B, [2]-N, [3]-λ, [4]-σ, [5]-μ
			total[ii]->SetParameters(aguess,bguess,peaky[ii],6,sigmaguess,peakx[ii]);//initial value [0]-A, [1]-B, [2]-N, [3]-τ, [4]-σ, [5]-μ
//			total[ii]->SetParameters(aguess,bguess,9,8,2,54590);//initial value [0]-A, [1]-B, [2]-N, [3]-τ, [4]-σ, [5]-μ
//			total[ii]->SetParameters(0,500,150000,0.7,1.5,3480);//initial value [0]-A, [1]-B, [2]-N, [3]-λ, [4]-σ, [5]-μ  //Glassman
// 			total[ii]->SetParLimits(0,-500,500);//Bkg A  //Glassman
// 			total[ii]->SetParLimits(1,-50000,300000);//Bkg B  //Glassman
 			total[ii]->SetParLimits(2,4,900);//Constant,min,max  //Glassman
			total[ii]->SetParLimits(3,0.1,500);//Tau  //Glassman portal
//			total[ii]->SetParLimits(3,8,8);//Tau  //Glassman portal
 			total[ii]->SetParLimits(4,1,49);//Sigma  //Glassman
 			total[ii]->SetParLimits(5,2000,63000);//Mean  //Glassman
			total[ii]->SetParNames("BkgA","BkgB","Const*bin","Tau","Sigma","Mean");
			sprintf(tauflag,"%s","tau8");
			histo[i]->Fit("total","MLE","",peakx[ii]-gaplow,peakx[ii]+gaphigh);///specify a range in the Fit
			//histo[i]->Fit("total","R+");//or restrict the fit to the range specified in the TF1 constructor: peakx[ii]-gaplow,peakx[ii]+gaphigh
			total[ii]->GetParameters(par[ii]);//二维数组的par[ii]是地址,pointer to the TF1, GetParameters的数组得是double类型Obtaining the value of parameters and saving them to par[]; 
			parerr[ii][0]=total[ii]->GetParError(0);//Obtaining the error of the 1st parameter
			parerr[ii][1]=total[ii]->GetParError(1);//Obtaining the error of the 2nd parameter
			parerr[ii][2]=total[ii]->GetParError(2);//Obtaining the error of the 3rd parameter
			parerr[ii][3]=total[ii]->GetParError(3);//Obtaining the error of the 4th parameter
			parerr[ii][4]=total[ii]->GetParError(4);//Obtaining the error of the 5th parameter
			parerr[ii][5]=total[ii]->GetParError(5);//Obtaining the error of the 6th parameter
			parchi[ii]=total[ii]->GetChisquare();
			parNDF[ii]=total[ii]->GetNDF();
			g[ii]->SetParameters(par[ii][2]*par[ii][4]*sqrt(3.141592654*2),par[ii][5],par[ii][4]);//set parameters for drawing gausn
			g[ii]->SetLineColor(4);
			p[ii]->SetParameters(par[ii][0],par[ii][1],par[ii][2],par[ii][3],par[ii][4],par[ii][5]);//set parameters for drawing peak
			p[ii]->SetLineColor(6);
			b[ii]->SetParameters(par[ii][0],par[ii][1]);//set parameters for drawing bkg
			b[ii]->SetLineColor(8);
			total[ii]->Draw("same");
			g[ii]->Draw("same");
			p[ii]->Draw("same");
			b[ii]->Draw("same");

			sig[ii]=par[ii][4]; sigerr[ii]=parerr[ii][4];
			tau[ii]=par[ii][3]; tauerr[ii]=parerr[ii][3];
			peaky[ii]=total[ii]->GetMaximum();
			peakx[ii]=total[ii]->GetMaximumX();
			peakxerr[ii]=parerr[ii][5];
// 			fprintf(outfile,"Constant%d=	%.1f%s%.3f\n",ii,par[ii][2]/binwidth,"	",parerr[2]/binwidth);//par数组还保持着刚才的参数
// 			fprintf(outfile,"Mean%d=	%.1f%s%.3f\n",ii,par[ii][5],"	",parerr[5]);
// 			fprintf(outfile,"Sigma%d=	%.3f%s%.3f\n",ii,par[ii][4],"	",parerr[4]);
// 			//fprintf(outfile,"Res%d=	%.2f%%\n",ii,par[ii][4]/par[ii][5]*2.355*100);
// 			fprintf(outfile,"Tau%d=	%.2f%s%.3f\n",ii,par[ii][3],"	",parerr[3]);
// 			fprintf(outfile,"A%d=	%.2f%s%.3f\nB%d=	%.1f%s%.3f\n",ii,par[ii][0],"	",parerr[0],ii,par[ii][1],"	",parerr[1]);
// 			fprintf(outfile,"Chisquare%d=	%.2f\n",ii,parchi);
// 			fprintf(outfile,"NDF%d=	%.2f\n",ii,parNDF);
// 			fprintf(outfile,"Maximum%d=	%.1f%s\n",ii,peakx[ii]);//par数组还保持着刚才的参数
			outfile<<"SeGA_"<<i<<"	Constant"<<ii<<"=	"<<par[ii][2]<<"	+/-	"<<parerr[ii][2]<<"	Mean"<<ii<<"=	"<<par[ii][5]<<"	+/-	"<<parerr[ii][5]<<"	Maximum"<<ii<<"=	"<<peakx[ii]<<"	Sigma"<<ii<<"=	"<<par[ii][4]<<"	+/-	"<<parerr[ii][4]<<"	Tau"<<ii<<"=	"<<par[ii][3]<<"	+/-	"<<parerr[ii][3]<<"	A"<<ii<<"=	"<<par[ii][0]<<"	+/-	"<<parerr[ii][0]<<"	B"<<ii<<"=	"<<par[ii][1]<<"	+/-	"<<parerr[ii][1]<<"	Chi2"<<ii<<"=	"<<parchi[ii]<<"	NDF"<<ii<<"=	"<<parNDF[ii]<<"	Area"<<ii<<"=	"<<sqrt(3.1415926536*2)*par[ii][2]*par[ii][4]<<endl;//输出文本查看
			//peakx[ii]=par[ii][1];// For graph pol fit, mean is more accurate than peakx
		
		//TF1 *g2=new TF1("g2","gaus",peakx[1]-gaplow/2,peakx[1]+gaphigh/2);//不同大小的峰有不同的拟合range，不适合写自动拟合循环
		//gStyle->SetFitColor(3);
		//h300AL[i]->Fit("g2","R+");//
		//TF1 *gt=new TF1("gt","gaus(0)+gaus(3)",peakx[0]-gaplow,peakx[1]+gaphigh);
		//g2->GetParameters(&par[3]);//Get到par数组，同时也做gt的Set数组，更自动
		//gt->SetParameters(par);//自动，两个高斯的参数做gt的初始化，In the more complicated case of the sum of 3 Gaussian functions, the initial values of parameters must be set. In this particular case, the initial values are taken from the result of the individual fits.
		//h300AL[i]->SetLineColor(1);
		//h300AL[i]->Fit("gt","R+");//+ means adding this new fitted function to the list of fitted functions (by default, the previous function is deleted and only the last one is kept)
		//double Sigma1=gt->GetParameter(2);//Obtaining the value of the 3rd parameter (Sigma)
		//double Mean1=gt->GetParameter(1);//Obtaining the value of the 2nd parameter (Mean)
		//double Sigma2=gt->GetParameter(5);//Obtaining the value of the 3rd parameter (Sigma)
		//double Mean2=gt->GetParameter(4);//Obtaining the value of the 2nd parameter (Mean)
			
			TPaveText *textgaus = new TPaveText(0.7,0.25,0.99,0.87,"brNDC");//加标注left, down, right, up
			textgaus->SetBorderSize(1);//边框宽度
			textgaus->SetFillColor(0);//填充颜色
			textgaus->SetTextAlign(12);//align = 10*HorizontalAlign + VerticalAlign, 12 means水平左对齐、垂直居中对齐
			textgaus->SetTextFont(132);//font = 10 * fontID + precision, 12+2,12 means Symbol; 13+2, 13 means News Times Roman
			//text->SetTextColor(2);//文本颜色
			sprintf(paraprint,"Constant%d=%.1f%s%.3f",ii,par[ii][2]/binwidth,"+/-",parerr[ii][2]/binwidth);//par数组还保持着刚才的参数
			textgaus->AddText(paraprint);
			sprintf(paraprint,"Mean%d=%.1f%s%.3f",ii,par[ii][5],"+/-",parerr[ii][5]);
			textgaus->AddText(paraprint);
			sprintf(paraprint,"Sigma%d=%.3f%s%.3f",ii,par[ii][4],"+/-",parerr[ii][4]);
			textgaus->AddText(paraprint);
			sprintf(paraprint,"Res%d=%.2f%%",ii,par[ii][4]/par[ii][5]*2.355*100);
			textgaus->AddText(paraprint);
			sprintf(paraprint,"Tau%d=%.2f%s%.3f",ii,par[ii][3],"+/-",parerr[ii][3]);
			textgaus->AddText(paraprint);
			sprintf(paraprint,"A%d(%.4f%s%.4f)*x+B%d(%.3f%s%.3f)",ii,par[ii][0],"+/-",parerr[ii][0],ii,par[ii][1],"+/-",parerr[ii][1]);
			textgaus->AddText(paraprint);
			sprintf(paraprint,"Chisquare%d=%.2f",ii,parchi[ii]);
			textgaus->AddText(paraprint);
			sprintf(paraprint,"NDF%d=%.2f",ii,parNDF[ii]);
			textgaus->AddText(paraprint);
			sprintf(paraprint,"Maximum%d=%.1f%s",ii,peakx[ii]);//par数组还保持着刚才的参数
			textgaus->AddText(paraprint);
			textgaus->Draw();
			sprintf(h_name,"D:/X/out/cali23Al/%s%s%d_%s.png",hfit_name,"_peak",ii,tauflag);//modify if change path
			canvaspeak[i]->SaveAs(h_name);//存图
		}//for(ii=0;ii<peaknum;ii++)
		outfile<<"\n\n"<<endl;
		//sprintf(paraprint,"Mean1=%4.2f",Mean1);//gt拟合参数，似乎寻峰不太准，拟合的Mean作峰位更准
		
		sprintf(hcali_name,"%s%d","sigma_Rn_all_SeGA_",i);
		canvascali[i]=new TCanvas(hcali_name,hcali_name,900,600);//建立画布
		canvascali[i]->cd();//进入画布
		//canvascali[i]->SetGrid();//显示网格
//		graph1[i]=new TGraph(peaknum,peakx,sig);//TGraph *gr1=new TGraph(n,x,y);
		//float eenergy[2]={200,280};
		//float epeakch[2]={0,0};
		graph1[i]= new TGraphErrors(peaknum,peakx,sig,peakxerr,sigerr);//画error bars TGraph(n,x,y,ex,ey);
		graph1[i]->SetTitle(hcali_name);
		graph1[i]->GetXaxis()->SetTitle("Channel");//轴名
		graph1[i]->GetYaxis()->SetTitle("Sigma");//轴名
		graph1[i]->GetXaxis()->CenterTitle();//居中
		graph1[i]->GetYaxis()->CenterTitle();//居中
		graph1[i]->GetXaxis()->SetLabelFont(132);//坐标字体
		graph1[i]->GetYaxis()->SetLabelFont(132);//坐标字体
		graph1[i]->GetXaxis()->SetTitleFont(132);//轴名字体
		graph1[i]->GetYaxis()->SetTitleFont(132);//轴名字体
		//graph1[i]->GetYaxis()->SetLabelSize(0.05);//坐标字号
		//graph1[i]->GetYaxis()->SetTitleSize(0.05);//轴名字号
		graph1[i]->GetXaxis()->SetTitleOffset(1.2);//轴名偏移
		graph1[i]->GetYaxis()->SetTitleOffset(1.3);//轴名偏移
		graph1[i]->SetMarkerStyle(21);
		graph1[i]->SetMarkerColor(1);
		TF1 *pol1=new TF1("pol1","pol1",0,50000);//多项式拟合，调节合适的拟合range
		graph1[i]->Fit("pol1");//pol1 can be used directly without TF1 constructor in CINT
		intercept[i]=pol1->GetParameter(0);
		slope[i]=pol1->GetParameter(1);
		intercepterr[i]=pol1->GetParError(0);
		slopeerr[i]=pol1->GetParError(1);
		graph1[i]->Draw("AP"); //A-Axis around the graph1,AP is suitable
		TPaveText *textpol1 = new TPaveText(0.13,0.74,0.55,0.89,"brNDC");//left, down, right, up
		textpol1->SetBorderSize(1);
		textpol1->SetFillColor(0);
		textpol1->SetTextAlign(12);//align = 10*HorizontalAlign + VerticalAlign, 12 means水平左对齐、垂直居中对齐
		textpol1->SetTextFont(132);//font = 10 * fontID + precision, 12+2,12 means Symbol; 13+2, 13 means News Times Roman
		sprintf(paraprint,"slope=%.9f+/-%.9f",slope[i],slopeerr[i]);
		textpol1->AddText(paraprint);
		sprintf(paraprint,"intercept=%.5f+/-%.5f",intercept[i],intercepterr[i]);
		textpol1->AddText(paraprint);
		textpol1->Draw();
		//sprintf(hcali_name,"%s.png",hcali_name);
		sprintf(hcali_name,"%s%s%s%s%s","D:/X/out/cali23Al/",hcali_name,"_",tauflag,".png");
		canvascali[i]->SaveAs(hcali_name);//存图
		outfile2<<"SeGA_"<<i<<"	sigslope=	"<<slope[i]<<"	+/-	"<<slopeerr[i]<<" sigintercept=	"<<intercept[i]<<"	+/-	"<<intercepterr[i]<<endl;
		
		sprintf(hcali_name,"%s%d","tau_Rn_all_SeGA_",i);
		canvascali[i]=new TCanvas(hcali_name,hcali_name,900,600);//建立画布
		canvascali[i]->cd();//进入画布
		//canvascali[i]->SetGrid();//显示网格
//		graph1[i]=new TGraph(peaknum,peakx,tau);//TGraph *gr1=new TGraph(n,x,y);
		//float eenergy[2]={200,280};
		//float epeakch[2]={0,0};
		graph2[i]= new TGraphErrors(peaknum,peakx,tau,peakxerr,tauerr);//画error bars TGraph(n,x,y,ex,ey);
		graph2[i]->SetTitle(hcali_name);
		graph2[i]->GetXaxis()->SetTitle("Channel");//轴名
		graph2[i]->GetYaxis()->SetTitle("Tau");//轴名
		graph2[i]->GetXaxis()->CenterTitle();//居中
		graph2[i]->GetYaxis()->CenterTitle();//居中
		graph2[i]->GetXaxis()->SetLabelFont(132);//坐标字体
		graph2[i]->GetYaxis()->SetLabelFont(132);//坐标字体
		graph2[i]->GetXaxis()->SetTitleFont(132);//轴名字体
		graph2[i]->GetYaxis()->SetTitleFont(132);//轴名字体
		//graph1[i]->GetYaxis()->SetLabelSize(0.05);//坐标字号
		//graph1[i]->GetYaxis()->SetTitleSize(0.05);//轴名字号
		graph2[i]->GetXaxis()->SetTitleOffset(1.2);//轴名偏移
		graph2[i]->GetYaxis()->SetTitleOffset(1.3);//轴名偏移
		graph2[i]->SetMarkerStyle(21);
		graph2[i]->SetMarkerColor(1);
		TF1 *pol1=new TF1("pol1","pol1",0,60000);//多项式拟合，调节合适的拟合range
		graph2[i]->Fit("pol1");//pol1 can be used directly without TF1 constructor in CINT
		intercept[i]=pol1->GetParameter(0);
		slope[i]=pol1->GetParameter(1);
		intercepterr[i]=pol1->GetParError(0);
		slopeerr[i]=pol1->GetParError(1);
		graph2[i]->Draw("AP"); //A-Axis around the graph1,AP is suitable
		TPaveText *textpol1 = new TPaveText(0.13,0.74,0.55,0.89,"brNDC");//left, down, right, up
		textpol1->SetBorderSize(1);
		textpol1->SetFillColor(0);
		textpol1->SetTextAlign(12);//align = 10*HorizontalAlign + VerticalAlign, 12 means水平左对齐、垂直居中对齐
		textpol1->SetTextFont(132);//font = 10 * fontID + precision, 12+2,12 means Symbol; 13+2, 13 means News Times Roman
		sprintf(paraprint,"slope=%.9f+/-%.9f",slope[i],slopeerr[i]);
		textpol1->AddText(paraprint);
		sprintf(paraprint,"intercept=%.5f+/-%.5f",intercept[i],intercepterr[i]);
		textpol1->AddText(paraprint);
		textpol1->Draw();
		//sprintf(hcali_name,"%s.png",hcali_name);
		sprintf(hcali_name,"%s%s%s%s%s","D:/X/out/cali23Al/",hcali_name,"_",tauflag,".png");
		canvascali[i]->SaveAs(hcali_name);//存图
		outfile2<<b_name<<i<<"	tauslope=	"<<slope[i]<<"	+/-	"<<slopeerr[i]<<" tauintercept=	"<<intercept[i]<<"	+/-	"<<intercepterr[i]<<endl;

		sprintf(hcali_name,"%s%d","Maximum_Rn_all_SeGA_",i);
		canvascali[i]=new TCanvas(hcali_name,hcali_name,900,600);//建立画布
		canvascali[i]->cd();//进入画布
		//canvascali[i]->SetGrid();//显示网格
//		graph1[i]=new TGraph(peaknum,peakx,sig);//TGraph *gr1=new TGraph(n,x,y);
		//float eenergy[2]={200,280};
		//float epeakch[2]={0,0};
		//memset(energyliterr,0,sizeof(energyliterr));
		graph[i]= new TGraphErrors(peaknum,peakx,energylit,peakxerr,energyliterr);//画error bars TGraph(n,x,y,ex,ey);
		graph[i]->SetTitle(hcali_name);
		graph[i]->GetXaxis()->SetTitle("Channel");//轴名
		graph[i]->GetYaxis()->SetTitle("Maximum");//轴名
		graph[i]->GetXaxis()->CenterTitle();//居中
		graph[i]->GetYaxis()->CenterTitle();//居中
		graph[i]->GetXaxis()->SetLabelFont(132);//坐标字体
		graph[i]->GetYaxis()->SetLabelFont(132);//坐标字体
		graph[i]->GetXaxis()->SetTitleFont(132);//轴名字体
		graph[i]->GetYaxis()->SetTitleFont(132);//轴名字体
		//graph1[i]->GetYaxis()->SetLabelSize(0.05);//坐标字号
		//graph1[i]->GetYaxis()->SetTitleSize(0.05);//轴名字号
		graph[i]->GetXaxis()->SetTitleOffset(1.2);//轴名偏移
		graph[i]->GetYaxis()->SetTitleOffset(1.3);//轴名偏移
		graph[i]->SetMarkerStyle(21);
		graph[i]->SetMarkerColor(1);
		TF1 *pol1=new TF1("pol1","pol1",0,60000);//多项式拟合，调节合适的拟合range
		graph[i]->Fit("pol1");//pol1 can be used directly without TF1 constructor in CINT
		intercept[i]=pol1->GetParameter(0);
		slope[i]=pol1->GetParameter(1);
		intercepterr[i]=pol1->GetParError(0);
		slopeerr[i]=pol1->GetParError(1);
		graph[i]->Draw("AP"); //A-Axis around the graph1,AP is suitable
		TPaveText *textpol1 = new TPaveText(0.13,0.74,0.55,0.89,"brNDC");//left, down, right, up
		textpol1->SetBorderSize(1);
		textpol1->SetFillColor(0);
		textpol1->SetTextAlign(12);//align = 10*HorizontalAlign + VerticalAlign, 12 means水平左对齐、垂直居中对齐
		textpol1->SetTextFont(132);//font = 10 * fontID + precision, 12+2,12 means Symbol; 13+2, 13 means News Times Roman
		sprintf(paraprint,"slope=%.9f+/-%.9f",slope[i],slopeerr[i]);
		textpol1->AddText(paraprint);
		sprintf(paraprint,"intercept=%.5f+/-%.5f",intercept[i],intercepterr[i]);
		textpol1->AddText(paraprint);
		textpol1->Draw();
		//sprintf(hcali_name,"%s.png",hcali_name);
		sprintf(hcali_name,"%s%s%s%s%s","D:/X/out/cali23Al/",hcali_name,"_",tauflag,".png");
		canvascali[i]->SaveAs(hcali_name);//存图
		outfile2<<"SeGA_"<<i<<"	calislope=	"<<slope[i]<<"	+/-	"<<slopeerr[i]<<"	caliintercept=	"<<intercept[i]<<"	+/-	"<<intercepterr[i]<<endl;
		
	}//for (i=0;i<ID;i++)
	//}//for(irawroot=runstart; irawroot<=runstop; irawroot++)
}//peakcali main